## DP 문제
- 작은 문제의 정답에서 큰 문제의 정답을 구할 수 있다. 
    - ex) X -> X/3 -> ... -> 1  =>  X->1의 답은 X/3->1의 답 +1
 
- 작은 문제에서 최소값을 선택해야 큰 문제도 최소가 된다.
    - ex) 12 -> 4 -> 1  /  12 -> 3 -> 1 / 12 -> 11 -> 1  => (4->1),(3->1),(11->1) 중 최소를 선택해야 12->1도 최소가 됨
    - 코드에서 D[n] = (D[n/3],D[n/2],D[n-1])의 최소값+1

- D[n/3],D[n/2],D[n-1]의 비교 순서는 상관없지만, D[n-1]은 조건에 상관없이 항상 수행될 수 있으므로 먼저 수행해줌
         

## 코드
```c++
#include <iostream>

int d[1000001]; //memoization 배열 (d[n]은 n->1로 만드는 최소값)
int recur(int n) {
    if (n == 1) { //가장 작은 크기의 문제
        return 0;
    }
    if (d[n] > 0) { //memoization 수행 : 이미 계산한 n이라면 메모에 저장되어 있던 값 리턴
        return d[n];
    }
    
    //계산되어 있는 값이 아니면 3가지 경우를 재귀호출
    
    d[n] = recur(n - 1) + 1; //최소값을 구하기 위해서는 비교해줄 값이 필요하므로 먼저 설정해줌
    
    //2로 나누어 떨어질 때 X=X/2
    if (n % 2 == 0) { 
        int temp = recur(n / 2) + 1;
        if (d[n] > temp) {
            d[n] = temp;
        }
    }
    
    //3으로 나누어 떨어질 때 X=X/3
    if (n % 3 == 0) {
        int temp = recur(n / 3) + 1;
        if (d[n] > temp) {
            d[n] = temp;
        }
    }
    return d[n]; // n->1로 만드는 최소값 리턴
}
int main() {
    int n;
    scanf("%d", &n);
    printf("%d\n", recur(n));
    return 0;
}
```
